#include <iostream>
using namespace std;


// Определение наименьшего общего делителя (возможно стоит вынести из класса)
int find_max_diveder(int a, int b){
    int t;
    while (b != 0) {
        t = b;
        b = a % b;
        a = t;
    }
        return a;
}



class Fraction{
    
private:
    int _numerator;
    int _denominator;


public:
    Fraction(int numerator, int denominator) : _numerator(numerator), 
                                               _denominator(denominator)
    {}
    
    Fraction() : _numerator(0), _denominator(1)
    {}
    
    // Конструктор копирования
    Fraction(const Fraction& obj) : _numerator(obj._numerator), _denominator(obj._denominator)
    {}
    
    
    int getNumerator() const { return this->_numerator; }
    int getDenominator() const { return this->_denominator; }
    void setNumerator(int num) { _numerator = num; }
    void setDenominator(int denom) { _denominator = denom; }
    
    // Вывод дроби
    void print(){
        cout << this->_numerator << "/" << this->_denominator << endl;
    }
    
    // Сокращение дроби
    void .......................................................................
    
    // Приведение дробей к общему знаменателю
    friend void to_common_denominator(Fraction& obj1, Fraction& obj2){
        
        // Находим наибольший общий делитель
        int max_diveder = find_max_diveder(
            obj1._denominator,
            obj2._denominator);
            
        // Если наибольший общий делитель 1
        if (max_diveder == 1){
            int tmp = obj1._denominator;
            obj1._denominator *= obj2._denominator;
            obj1._numerator *= obj2._denominator;
            obj2._denominator *= tmp;
            obj2._numerator *= tmp;
            
        }
        // Если знаменатель второрй дроби больше чем знаменатель первой
        else if (obj2._denominator > obj1._denominator){
            // Множитель на который домножаем первую дробь
            int mult = obj2._denominator / max_diveder;
            obj1._denominator *= mult;
            obj1._numerator = obj1._numerator * mult + obj2._numerator; 
        }
        // Если знаменатель первой дроби больше чем знаменатель второй
        else if (obj1._denominator > obj2._denominator){
            // Множитель на который домножаем вторую дробь
            int mult = obj1._denominator / max_diveder;
            obj1._numerator = obj1._numerator + obj2._numerator * mult;
        }
        else{
            cout << "Произошла непредвиденная ошибка." << endl;
        }
    }
    
    
    /*Сумма дробей
    - метод класса принимает объект класса Fraction
    - возврщает указатель на объект класса(меняет первую дробь)*/
    Fraction& SumFraction(const Fraction& obj){
        
        // Копируем объект obj (второе слагаемое)
        Fraction obj_copy(obj);
        // Приводим дроби к общему знаменателю
        to_common_denominator(*this, obj_copy);
        this->_numerator += obj_copy._numerator;
        return *this;
    }
    
    
    

    
        

    // Перегрузка оператора +
    Fraction& operator+=(Fraction& obj){
        // Получаем наибольший общий делитель
        int max_diveder = find_max_diveder(
            this->_denominator,
            obj._denominator);
        
        // Если наибольший общий делитель 1
        if (max_diveder == 1){
            this->_numerator = this->_numerator * obj._denominator 
                             + obj._numerator * this->_denominator;
            this->_denominator *= obj._denominator;
        }
        
        
        return *this;
    }
};





int main(){
    setlocale(LC_ALL, "RU");
    
    Fraction obj1(1, 5);
    Fraction obj2(2, 7);
    
    obj1.SumFraction(obj2);
    obj1.print();
    

    
    
    
    
    
}